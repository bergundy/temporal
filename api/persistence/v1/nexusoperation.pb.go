// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Copyright (c) 2020 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: temporal/server/api/persistence/v1/nexusoperation.proto

package persistence

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Open questions, can the call state keep transitioning after a workflow has
// completed? Doesn't seem to happen with child workflow. After workflow
// completes, we won't know e.g. if cancellation is eventually processed.
type StateMachineTransition struct {
	// Event id of the correlating history event (only set if the workflow was
	// open at transition time).
	EventId int64 `protobuf:"varint,1,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// TODO: we may want this as a reference later
	// ID of the event batch containing the event_id above
	// int64 event_batch_id = 2;
	// TODO: do we want to store this here?
	// (-- api-linter: core::0142::time-field-names=disabled
	//     aip.dev/not-precedent: it's okay not to end with _time if the name is
	//     time. --)
	Time *time.Time `protobuf:"bytes,3,opt,name=time,proto3,stdtime" json:"time,omitempty"`
}

func (m *StateMachineTransition) Reset()      { *m = StateMachineTransition{} }
func (*StateMachineTransition) ProtoMessage() {}
func (*StateMachineTransition) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d3bc723eaaa8c5e, []int{0}
}
func (m *StateMachineTransition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineTransition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineTransition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineTransition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineTransition.Merge(m, src)
}
func (m *StateMachineTransition) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineTransition) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineTransition.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineTransition proto.InternalMessageInfo

func (m *StateMachineTransition) GetEventId() int64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *StateMachineTransition) GetTime() *time.Time {
	if m != nil {
		return m.Time
	}
	return nil
}

// Initial call state. A successful request has yet to be recorded.
type NexusOperationScheduled struct {
	// Incremented every time before an attempt is made to transmit this call.
	// Before? After? Before but without waiting for DB flush?
	// Assuming at least once semantics, do we need to commit before?
	Attempt int64 `protobuf:"varint,1,opt,name=attempt,proto3" json:"attempt,omitempty"`
}

func (m *NexusOperationScheduled) Reset()      { *m = NexusOperationScheduled{} }
func (*NexusOperationScheduled) ProtoMessage() {}
func (*NexusOperationScheduled) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d3bc723eaaa8c5e, []int{1}
}
func (m *NexusOperationScheduled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexusOperationScheduled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexusOperationScheduled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexusOperationScheduled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexusOperationScheduled.Merge(m, src)
}
func (m *NexusOperationScheduled) XXX_Size() int {
	return m.Size()
}
func (m *NexusOperationScheduled) XXX_DiscardUnknown() {
	xxx_messageInfo_NexusOperationScheduled.DiscardUnknown(m)
}

var xxx_messageInfo_NexusOperationScheduled proto.InternalMessageInfo

func (m *NexusOperationScheduled) GetAttempt() int64 {
	if m != nil {
		return m.Attempt
	}
	return 0
}

// Call was accepted by a handler, to be completed later via a callback.
type NexusOperationStarted struct {
	Transition *StateMachineTransition `protobuf:"bytes,1,opt,name=transition,proto3" json:"transition,omitempty"`
	// ID returned by a handler which can be used to reference this call (e.g. for
	// issuing a cancellation).
	OperationId string `protobuf:"bytes,2,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// A reference to the previous state (scheduled).
	PreviousState *NexusOperationScheduled `protobuf:"bytes,3,opt,name=previous_state,json=previousState,proto3" json:"previous_state,omitempty"`
}

func (m *NexusOperationStarted) Reset()      { *m = NexusOperationStarted{} }
func (*NexusOperationStarted) ProtoMessage() {}
func (*NexusOperationStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d3bc723eaaa8c5e, []int{2}
}
func (m *NexusOperationStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexusOperationStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexusOperationStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexusOperationStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexusOperationStarted.Merge(m, src)
}
func (m *NexusOperationStarted) XXX_Size() int {
	return m.Size()
}
func (m *NexusOperationStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_NexusOperationStarted.DiscardUnknown(m)
}

var xxx_messageInfo_NexusOperationStarted proto.InternalMessageInfo

func (m *NexusOperationStarted) GetTransition() *StateMachineTransition {
	if m != nil {
		return m.Transition
	}
	return nil
}

func (m *NexusOperationStarted) GetOperationId() string {
	if m != nil {
		return m.OperationId
	}
	return ""
}

func (m *NexusOperationStarted) GetPreviousState() *NexusOperationScheduled {
	if m != nil {
		return m.PreviousState
	}
	return nil
}

// Call has succeeded either by a handler responding inline or asynchrnously via
// a callback.
// Result is stored in history and can be looked up by the transition's event
// information.
type NexusOperationSucceeded struct {
	Transition *StateMachineTransition `protobuf:"bytes,1,opt,name=transition,proto3" json:"transition,omitempty"`
	// Types that are valid to be assigned to PreviousState:
	//	*NexusOperationSucceeded_Scheduled
	//	*NexusOperationSucceeded_Started
	//	*NexusOperationSucceeded_CancelScheduled
	//	*NexusOperationSucceeded_CancelStarted
	PreviousState isNexusOperationSucceeded_PreviousState `protobuf_oneof:"previous_state"`
}

func (m *NexusOperationSucceeded) Reset()      { *m = NexusOperationSucceeded{} }
func (*NexusOperationSucceeded) ProtoMessage() {}
func (*NexusOperationSucceeded) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d3bc723eaaa8c5e, []int{3}
}
func (m *NexusOperationSucceeded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexusOperationSucceeded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexusOperationSucceeded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexusOperationSucceeded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexusOperationSucceeded.Merge(m, src)
}
func (m *NexusOperationSucceeded) XXX_Size() int {
	return m.Size()
}
func (m *NexusOperationSucceeded) XXX_DiscardUnknown() {
	xxx_messageInfo_NexusOperationSucceeded.DiscardUnknown(m)
}

var xxx_messageInfo_NexusOperationSucceeded proto.InternalMessageInfo

type isNexusOperationSucceeded_PreviousState interface {
	isNexusOperationSucceeded_PreviousState()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NexusOperationSucceeded_Scheduled struct {
	Scheduled *NexusOperationScheduled `protobuf:"bytes,2,opt,name=scheduled,proto3,oneof" json:"scheduled,omitempty"`
}
type NexusOperationSucceeded_Started struct {
	Started *NexusOperationStarted `protobuf:"bytes,3,opt,name=started,proto3,oneof" json:"started,omitempty"`
}
type NexusOperationSucceeded_CancelScheduled struct {
	CancelScheduled *NexusOperationCancelScheduled `protobuf:"bytes,4,opt,name=cancel_scheduled,json=cancelScheduled,proto3,oneof" json:"cancel_scheduled,omitempty"`
}
type NexusOperationSucceeded_CancelStarted struct {
	CancelStarted *NexusOperationCancelStarted `protobuf:"bytes,5,opt,name=cancel_started,json=cancelStarted,proto3,oneof" json:"cancel_started,omitempty"`
}

func (*NexusOperationSucceeded_Scheduled) isNexusOperationSucceeded_PreviousState()       {}
func (*NexusOperationSucceeded_Started) isNexusOperationSucceeded_PreviousState()         {}
func (*NexusOperationSucceeded_CancelScheduled) isNexusOperationSucceeded_PreviousState() {}
func (*NexusOperationSucceeded_CancelStarted) isNexusOperationSucceeded_PreviousState()   {}

func (m *NexusOperationSucceeded) GetPreviousState() isNexusOperationSucceeded_PreviousState {
	if m != nil {
		return m.PreviousState
	}
	return nil
}

func (m *NexusOperationSucceeded) GetTransition() *StateMachineTransition {
	if m != nil {
		return m.Transition
	}
	return nil
}

func (m *NexusOperationSucceeded) GetScheduled() *NexusOperationScheduled {
	if x, ok := m.GetPreviousState().(*NexusOperationSucceeded_Scheduled); ok {
		return x.Scheduled
	}
	return nil
}

func (m *NexusOperationSucceeded) GetStarted() *NexusOperationStarted {
	if x, ok := m.GetPreviousState().(*NexusOperationSucceeded_Started); ok {
		return x.Started
	}
	return nil
}

func (m *NexusOperationSucceeded) GetCancelScheduled() *NexusOperationCancelScheduled {
	if x, ok := m.GetPreviousState().(*NexusOperationSucceeded_CancelScheduled); ok {
		return x.CancelScheduled
	}
	return nil
}

func (m *NexusOperationSucceeded) GetCancelStarted() *NexusOperationCancelStarted {
	if x, ok := m.GetPreviousState().(*NexusOperationSucceeded_CancelStarted); ok {
		return x.CancelStarted
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NexusOperationSucceeded) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NexusOperationSucceeded_Scheduled)(nil),
		(*NexusOperationSucceeded_Started)(nil),
		(*NexusOperationSucceeded_CancelScheduled)(nil),
		(*NexusOperationSucceeded_CancelStarted)(nil),
	}
}

// Call has failed either by a handler responding inline or asynchrnously via
// a callback.
// Result is stored in history and can be looked up by the transition's event
// information.
type NexusOperationFailed struct {
	Transition *StateMachineTransition `protobuf:"bytes,1,opt,name=transition,proto3" json:"transition,omitempty"`
	// Types that are valid to be assigned to PreviousState:
	//	*NexusOperationFailed_Scheduled
	//	*NexusOperationFailed_Started
	//	*NexusOperationFailed_CancelScheduled
	//	*NexusOperationFailed_CancelStarted
	PreviousState isNexusOperationFailed_PreviousState `protobuf_oneof:"previous_state"`
}

func (m *NexusOperationFailed) Reset()      { *m = NexusOperationFailed{} }
func (*NexusOperationFailed) ProtoMessage() {}
func (*NexusOperationFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d3bc723eaaa8c5e, []int{4}
}
func (m *NexusOperationFailed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexusOperationFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexusOperationFailed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexusOperationFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexusOperationFailed.Merge(m, src)
}
func (m *NexusOperationFailed) XXX_Size() int {
	return m.Size()
}
func (m *NexusOperationFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_NexusOperationFailed.DiscardUnknown(m)
}

var xxx_messageInfo_NexusOperationFailed proto.InternalMessageInfo

type isNexusOperationFailed_PreviousState interface {
	isNexusOperationFailed_PreviousState()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NexusOperationFailed_Scheduled struct {
	Scheduled *NexusOperationScheduled `protobuf:"bytes,2,opt,name=scheduled,proto3,oneof" json:"scheduled,omitempty"`
}
type NexusOperationFailed_Started struct {
	Started *NexusOperationStarted `protobuf:"bytes,3,opt,name=started,proto3,oneof" json:"started,omitempty"`
}
type NexusOperationFailed_CancelScheduled struct {
	CancelScheduled *NexusOperationCancelScheduled `protobuf:"bytes,4,opt,name=cancel_scheduled,json=cancelScheduled,proto3,oneof" json:"cancel_scheduled,omitempty"`
}
type NexusOperationFailed_CancelStarted struct {
	CancelStarted *NexusOperationCancelStarted `protobuf:"bytes,5,opt,name=cancel_started,json=cancelStarted,proto3,oneof" json:"cancel_started,omitempty"`
}

func (*NexusOperationFailed_Scheduled) isNexusOperationFailed_PreviousState()       {}
func (*NexusOperationFailed_Started) isNexusOperationFailed_PreviousState()         {}
func (*NexusOperationFailed_CancelScheduled) isNexusOperationFailed_PreviousState() {}
func (*NexusOperationFailed_CancelStarted) isNexusOperationFailed_PreviousState()   {}

func (m *NexusOperationFailed) GetPreviousState() isNexusOperationFailed_PreviousState {
	if m != nil {
		return m.PreviousState
	}
	return nil
}

func (m *NexusOperationFailed) GetTransition() *StateMachineTransition {
	if m != nil {
		return m.Transition
	}
	return nil
}

func (m *NexusOperationFailed) GetScheduled() *NexusOperationScheduled {
	if x, ok := m.GetPreviousState().(*NexusOperationFailed_Scheduled); ok {
		return x.Scheduled
	}
	return nil
}

func (m *NexusOperationFailed) GetStarted() *NexusOperationStarted {
	if x, ok := m.GetPreviousState().(*NexusOperationFailed_Started); ok {
		return x.Started
	}
	return nil
}

func (m *NexusOperationFailed) GetCancelScheduled() *NexusOperationCancelScheduled {
	if x, ok := m.GetPreviousState().(*NexusOperationFailed_CancelScheduled); ok {
		return x.CancelScheduled
	}
	return nil
}

func (m *NexusOperationFailed) GetCancelStarted() *NexusOperationCancelStarted {
	if x, ok := m.GetPreviousState().(*NexusOperationFailed_CancelStarted); ok {
		return x.CancelStarted
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NexusOperationFailed) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NexusOperationFailed_Scheduled)(nil),
		(*NexusOperationFailed_Started)(nil),
		(*NexusOperationFailed_CancelScheduled)(nil),
		(*NexusOperationFailed_CancelStarted)(nil),
	}
}

// The user specified timeout has expired. A handler may or may not have
// received this call.
type NexusOperationTimedOut struct {
	Transition *StateMachineTransition `protobuf:"bytes,1,opt,name=transition,proto3" json:"transition,omitempty"`
	// Types that are valid to be assigned to PreviousState:
	//	*NexusOperationTimedOut_Scheduled
	//	*NexusOperationTimedOut_Started
	//	*NexusOperationTimedOut_CancelScheduled
	//	*NexusOperationTimedOut_CancelStarted
	PreviousState isNexusOperationTimedOut_PreviousState `protobuf_oneof:"previous_state"`
}

func (m *NexusOperationTimedOut) Reset()      { *m = NexusOperationTimedOut{} }
func (*NexusOperationTimedOut) ProtoMessage() {}
func (*NexusOperationTimedOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d3bc723eaaa8c5e, []int{5}
}
func (m *NexusOperationTimedOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexusOperationTimedOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexusOperationTimedOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexusOperationTimedOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexusOperationTimedOut.Merge(m, src)
}
func (m *NexusOperationTimedOut) XXX_Size() int {
	return m.Size()
}
func (m *NexusOperationTimedOut) XXX_DiscardUnknown() {
	xxx_messageInfo_NexusOperationTimedOut.DiscardUnknown(m)
}

var xxx_messageInfo_NexusOperationTimedOut proto.InternalMessageInfo

type isNexusOperationTimedOut_PreviousState interface {
	isNexusOperationTimedOut_PreviousState()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NexusOperationTimedOut_Scheduled struct {
	Scheduled *NexusOperationScheduled `protobuf:"bytes,2,opt,name=scheduled,proto3,oneof" json:"scheduled,omitempty"`
}
type NexusOperationTimedOut_Started struct {
	Started *NexusOperationStarted `protobuf:"bytes,3,opt,name=started,proto3,oneof" json:"started,omitempty"`
}
type NexusOperationTimedOut_CancelScheduled struct {
	CancelScheduled *NexusOperationCancelScheduled `protobuf:"bytes,4,opt,name=cancel_scheduled,json=cancelScheduled,proto3,oneof" json:"cancel_scheduled,omitempty"`
}
type NexusOperationTimedOut_CancelStarted struct {
	CancelStarted *NexusOperationCancelStarted `protobuf:"bytes,5,opt,name=cancel_started,json=cancelStarted,proto3,oneof" json:"cancel_started,omitempty"`
}

func (*NexusOperationTimedOut_Scheduled) isNexusOperationTimedOut_PreviousState()       {}
func (*NexusOperationTimedOut_Started) isNexusOperationTimedOut_PreviousState()         {}
func (*NexusOperationTimedOut_CancelScheduled) isNexusOperationTimedOut_PreviousState() {}
func (*NexusOperationTimedOut_CancelStarted) isNexusOperationTimedOut_PreviousState()   {}

func (m *NexusOperationTimedOut) GetPreviousState() isNexusOperationTimedOut_PreviousState {
	if m != nil {
		return m.PreviousState
	}
	return nil
}

func (m *NexusOperationTimedOut) GetTransition() *StateMachineTransition {
	if m != nil {
		return m.Transition
	}
	return nil
}

func (m *NexusOperationTimedOut) GetScheduled() *NexusOperationScheduled {
	if x, ok := m.GetPreviousState().(*NexusOperationTimedOut_Scheduled); ok {
		return x.Scheduled
	}
	return nil
}

func (m *NexusOperationTimedOut) GetStarted() *NexusOperationStarted {
	if x, ok := m.GetPreviousState().(*NexusOperationTimedOut_Started); ok {
		return x.Started
	}
	return nil
}

func (m *NexusOperationTimedOut) GetCancelScheduled() *NexusOperationCancelScheduled {
	if x, ok := m.GetPreviousState().(*NexusOperationTimedOut_CancelScheduled); ok {
		return x.CancelScheduled
	}
	return nil
}

func (m *NexusOperationTimedOut) GetCancelStarted() *NexusOperationCancelStarted {
	if x, ok := m.GetPreviousState().(*NexusOperationTimedOut_CancelStarted); ok {
		return x.CancelStarted
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NexusOperationTimedOut) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NexusOperationTimedOut_Scheduled)(nil),
		(*NexusOperationTimedOut_Started)(nil),
		(*NexusOperationTimedOut_CancelScheduled)(nil),
		(*NexusOperationTimedOut_CancelStarted)(nil),
	}
}

// Call should be cancelled, a cancellation request should be sent to the
// handler.
// TODO: this is incomplete
type NexusOperationCancelScheduled struct {
	Transition *StateMachineTransition `protobuf:"bytes,1,opt,name=transition,proto3" json:"transition,omitempty"`
	// Types that are valid to be assigned to PreviousState:
	//	*NexusOperationCancelScheduled_Scheduled
	//	*NexusOperationCancelScheduled_Started
	PreviousState isNexusOperationCancelScheduled_PreviousState `protobuf_oneof:"previous_state"`
}

func (m *NexusOperationCancelScheduled) Reset()      { *m = NexusOperationCancelScheduled{} }
func (*NexusOperationCancelScheduled) ProtoMessage() {}
func (*NexusOperationCancelScheduled) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d3bc723eaaa8c5e, []int{6}
}
func (m *NexusOperationCancelScheduled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexusOperationCancelScheduled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexusOperationCancelScheduled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexusOperationCancelScheduled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexusOperationCancelScheduled.Merge(m, src)
}
func (m *NexusOperationCancelScheduled) XXX_Size() int {
	return m.Size()
}
func (m *NexusOperationCancelScheduled) XXX_DiscardUnknown() {
	xxx_messageInfo_NexusOperationCancelScheduled.DiscardUnknown(m)
}

var xxx_messageInfo_NexusOperationCancelScheduled proto.InternalMessageInfo

type isNexusOperationCancelScheduled_PreviousState interface {
	isNexusOperationCancelScheduled_PreviousState()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NexusOperationCancelScheduled_Scheduled struct {
	Scheduled *NexusOperationScheduled `protobuf:"bytes,2,opt,name=scheduled,proto3,oneof" json:"scheduled,omitempty"`
}
type NexusOperationCancelScheduled_Started struct {
	Started *NexusOperationStarted `protobuf:"bytes,3,opt,name=started,proto3,oneof" json:"started,omitempty"`
}

func (*NexusOperationCancelScheduled_Scheduled) isNexusOperationCancelScheduled_PreviousState() {}
func (*NexusOperationCancelScheduled_Started) isNexusOperationCancelScheduled_PreviousState()   {}

func (m *NexusOperationCancelScheduled) GetPreviousState() isNexusOperationCancelScheduled_PreviousState {
	if m != nil {
		return m.PreviousState
	}
	return nil
}

func (m *NexusOperationCancelScheduled) GetTransition() *StateMachineTransition {
	if m != nil {
		return m.Transition
	}
	return nil
}

func (m *NexusOperationCancelScheduled) GetScheduled() *NexusOperationScheduled {
	if x, ok := m.GetPreviousState().(*NexusOperationCancelScheduled_Scheduled); ok {
		return x.Scheduled
	}
	return nil
}

func (m *NexusOperationCancelScheduled) GetStarted() *NexusOperationStarted {
	if x, ok := m.GetPreviousState().(*NexusOperationCancelScheduled_Started); ok {
		return x.Started
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NexusOperationCancelScheduled) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NexusOperationCancelScheduled_Scheduled)(nil),
		(*NexusOperationCancelScheduled_Started)(nil),
	}
}

// A cancellation request has been sent to a handler which *should* eventually
// process it. There's no guarantee that the operation will end up in cancelled
// state.
// TODO: this is incomplete
type NexusOperationCancelStarted struct {
	// Event id of the CallSucceeded event
	EventId int64 `protobuf:"varint,1,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// Id of the event batch containing the event_id above
	EventBatchId int64 `protobuf:"varint,2,opt,name=event_batch_id,json=eventBatchId,proto3" json:"event_batch_id,omitempty"`
	// TODO: do we want to store this here?
	// (-- api-linter: core::0142::time-field-names=disabled
	//     aip.dev/not-precedent: it's okay not to end with _time if the name is
	//     time. --)
	Time *time.Time `protobuf:"bytes,3,opt,name=time,proto3,stdtime" json:"time,omitempty"`
	// This will only be set if the call ever transitioned to started state.
	StartedState *NexusOperationStarted `protobuf:"bytes,4,opt,name=started_state,json=startedState,proto3" json:"started_state,omitempty"`
}

func (m *NexusOperationCancelStarted) Reset()      { *m = NexusOperationCancelStarted{} }
func (*NexusOperationCancelStarted) ProtoMessage() {}
func (*NexusOperationCancelStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d3bc723eaaa8c5e, []int{7}
}
func (m *NexusOperationCancelStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexusOperationCancelStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexusOperationCancelStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexusOperationCancelStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexusOperationCancelStarted.Merge(m, src)
}
func (m *NexusOperationCancelStarted) XXX_Size() int {
	return m.Size()
}
func (m *NexusOperationCancelStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_NexusOperationCancelStarted.DiscardUnknown(m)
}

var xxx_messageInfo_NexusOperationCancelStarted proto.InternalMessageInfo

func (m *NexusOperationCancelStarted) GetEventId() int64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *NexusOperationCancelStarted) GetEventBatchId() int64 {
	if m != nil {
		return m.EventBatchId
	}
	return 0
}

func (m *NexusOperationCancelStarted) GetTime() *time.Time {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *NexusOperationCancelStarted) GetStartedState() *NexusOperationStarted {
	if m != nil {
		return m.StartedState
	}
	return nil
}

func init() {
	proto.RegisterType((*StateMachineTransition)(nil), "temporal.server.api.persistence.v1.StateMachineTransition")
	proto.RegisterType((*NexusOperationScheduled)(nil), "temporal.server.api.persistence.v1.NexusOperationScheduled")
	proto.RegisterType((*NexusOperationStarted)(nil), "temporal.server.api.persistence.v1.NexusOperationStarted")
	proto.RegisterType((*NexusOperationSucceeded)(nil), "temporal.server.api.persistence.v1.NexusOperationSucceeded")
	proto.RegisterType((*NexusOperationFailed)(nil), "temporal.server.api.persistence.v1.NexusOperationFailed")
	proto.RegisterType((*NexusOperationTimedOut)(nil), "temporal.server.api.persistence.v1.NexusOperationTimedOut")
	proto.RegisterType((*NexusOperationCancelScheduled)(nil), "temporal.server.api.persistence.v1.NexusOperationCancelScheduled")
	proto.RegisterType((*NexusOperationCancelStarted)(nil), "temporal.server.api.persistence.v1.NexusOperationCancelStarted")
}

func init() {
	proto.RegisterFile("temporal/server/api/persistence/v1/nexusoperation.proto", fileDescriptor_6d3bc723eaaa8c5e)
}

var fileDescriptor_6d3bc723eaaa8c5e = []byte{
	// 612 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x96, 0xbf, 0x6f, 0xd3, 0x40,
	0x14, 0xc7, 0x7d, 0xad, 0xa1, 0xf4, 0x9a, 0x84, 0xca, 0x82, 0x12, 0x82, 0xb8, 0xa6, 0x16, 0x43,
	0x26, 0x5b, 0xfd, 0x21, 0x21, 0xe8, 0x80, 0x08, 0x12, 0x6a, 0x07, 0xa8, 0xe4, 0x96, 0xa5, 0x48,
	0x44, 0x17, 0xfb, 0x91, 0x1c, 0x4a, 0x7c, 0x96, 0x7d, 0x8e, 0x18, 0xf9, 0x13, 0x2a, 0x04, 0xff,
	0x03, 0xff, 0x06, 0x1b, 0x63, 0xc6, 0x6e, 0x10, 0x67, 0x61, 0xec, 0xc0, 0xc4, 0x84, 0x7c, 0xb6,
	0xf3, 0xa3, 0xb4, 0x01, 0x52, 0x31, 0x35, 0x5b, 0xee, 0xe5, 0xde, 0xe7, 0x7d, 0xbf, 0xef, 0x9e,
	0xac, 0x87, 0xef, 0x0b, 0x68, 0x7b, 0xdc, 0xa7, 0x2d, 0x33, 0x00, 0xbf, 0x03, 0xbe, 0x49, 0x3d,
	0x66, 0x7a, 0xe0, 0x07, 0x2c, 0x10, 0xe0, 0xda, 0x60, 0x76, 0xd6, 0x4d, 0x17, 0xde, 0x86, 0x01,
	0xf7, 0xc0, 0xa7, 0x82, 0x71, 0xd7, 0xf0, 0x7c, 0x2e, 0xb8, 0xa6, 0x67, 0x89, 0x46, 0x92, 0x68,
	0x50, 0x8f, 0x19, 0x23, 0x89, 0x46, 0x67, 0xbd, 0xb4, 0xda, 0xe0, 0xbc, 0xd1, 0x02, 0x53, 0x66,
	0xd4, 0xc3, 0xd7, 0xa6, 0x60, 0x6d, 0x08, 0x04, 0x6d, 0x7b, 0x09, 0xa4, 0xb4, 0xe6, 0x80, 0x07,
	0xae, 0x03, 0xae, 0xcd, 0x20, 0x30, 0x1b, 0xbc, 0xc1, 0x65, 0x5c, 0xfe, 0x4a, 0xae, 0xe8, 0x0c,
	0xaf, 0xec, 0x0b, 0x2a, 0xe0, 0x19, 0xb5, 0x9b, 0xcc, 0x85, 0x03, 0x9f, 0xba, 0x01, 0x8b, 0x75,
	0x68, 0xb7, 0xf1, 0x35, 0xe8, 0x80, 0x2b, 0x6a, 0xcc, 0x29, 0xa2, 0x32, 0xaa, 0xcc, 0x5b, 0x0b,
	0xf2, 0xbc, 0xeb, 0x68, 0x5b, 0x58, 0x8d, 0x4b, 0x15, 0xe7, 0xcb, 0xa8, 0xb2, 0xb4, 0x51, 0x32,
	0x12, 0x1d, 0x46, 0xa6, 0xc3, 0x38, 0xc8, 0x74, 0x54, 0xd5, 0xa3, 0xaf, 0xab, 0xc8, 0x92, 0xb7,
	0xf5, 0x4d, 0x7c, 0xeb, 0x79, 0x6c, 0x75, 0x2f, 0xb3, 0xba, 0x6f, 0x37, 0xc1, 0x09, 0x5b, 0xe0,
	0x68, 0x45, 0xbc, 0x40, 0x45, 0xec, 0x58, 0x64, 0xa5, 0xd2, 0xa3, 0xfe, 0x13, 0xe1, 0x9b, 0xa7,
	0xb2, 0x04, 0xf5, 0x05, 0x38, 0xda, 0x21, 0xc6, 0x62, 0xa0, 0x56, 0xa6, 0x2d, 0x6d, 0x3c, 0x34,
	0xfe, 0xdc, 0x36, 0xe3, 0x6c, 0xbf, 0xd6, 0x08, 0x4d, 0x5b, 0xc3, 0xb9, 0xc1, 0x83, 0xc4, 0xfe,
	0xe7, 0xca, 0xa8, 0xb2, 0x68, 0x2d, 0x0d, 0x62, 0xbb, 0x8e, 0x56, 0xc7, 0x05, 0xcf, 0x87, 0x0e,
	0xe3, 0x61, 0x50, 0x0b, 0x62, 0x62, 0xda, 0x8d, 0xed, 0xbf, 0x91, 0x70, 0x4e, 0x1f, 0xac, 0x7c,
	0x86, 0x94, 0x1a, 0xf5, 0x8f, 0xea, 0x6f, 0x2d, 0x0b, 0x6d, 0x1b, 0xc0, 0xf9, 0xcf, 0xf6, 0x5f,
	0xe2, 0xc5, 0x20, 0xd3, 0x24, 0xbd, 0x5f, 0xcc, 0xd6, 0x8e, 0x62, 0x0d, 0x79, 0xda, 0x0b, 0xbc,
	0x10, 0x24, 0x4f, 0x98, 0x76, 0xec, 0xc1, 0x14, 0xe8, 0x04, 0xb0, 0xa3, 0x58, 0x19, 0x4b, 0x73,
	0xf1, 0xb2, 0x4d, 0x5d, 0x1b, 0x5a, 0xb5, 0xa1, 0x74, 0x55, 0xf2, 0x1f, 0xff, 0x3b, 0xff, 0x89,
	0x24, 0x8d, 0x1a, 0xb8, 0x6e, 0x8f, 0x87, 0xb4, 0x26, 0x2e, 0x64, 0xf5, 0x52, 0x37, 0x57, 0x64,
	0xb5, 0x47, 0x53, 0x57, 0x1b, 0x78, 0xca, 0xdb, 0xa3, 0x81, 0xea, 0xf2, 0xe9, 0x49, 0xd3, 0xdf,
	0xab, 0xf8, 0xc6, 0x38, 0xe2, 0x29, 0x65, 0xad, 0xd9, 0x50, 0x5c, 0xea, 0xa1, 0xf8, 0xa0, 0xe2,
	0x95, 0x71, 0x44, 0xfc, 0x19, 0x76, 0xf6, 0x42, 0x31, 0x1b, 0x8b, 0x4b, 0x3c, 0x16, 0x9f, 0xe7,
	0xf0, 0xdd, 0x89, 0x82, 0x67, 0xd3, 0x31, 0x3e, 0x1d, 0x67, 0xf4, 0xf0, 0x07, 0xc2, 0x77, 0x26,
	0x3c, 0xc3, 0xa4, 0x55, 0xe9, 0x1e, 0x2e, 0x24, 0x7f, 0xd5, 0xa9, 0xb0, 0x9b, 0xd9, 0x2e, 0x31,
	0x6f, 0xe5, 0x64, 0xb4, 0x1a, 0x07, 0xa7, 0x5d, 0xa8, 0xb4, 0x57, 0x38, 0x9f, 0x6a, 0x4e, 0x37,
	0x10, 0xf5, 0x82, 0x5d, 0xb0, 0x72, 0x29, 0x4f, 0xbe, 0x6c, 0xf5, 0x4d, 0xb7, 0x47, 0x94, 0xe3,
	0x1e, 0x51, 0x4e, 0x7a, 0x04, 0xbd, 0x8b, 0x08, 0xfa, 0x14, 0x11, 0xf4, 0x25, 0x22, 0xa8, 0x1b,
	0x11, 0xf4, 0x2d, 0x22, 0xe8, 0x7b, 0x44, 0x94, 0x93, 0x88, 0xa0, 0xa3, 0x3e, 0x51, 0xba, 0x7d,
	0xa2, 0x1c, 0xf7, 0x89, 0x72, 0xb8, 0xd5, 0xe0, 0x43, 0x01, 0x8c, 0x9f, 0xbf, 0xf8, 0x6e, 0x8f,
	0x1c, 0xeb, 0x57, 0xa5, 0xd7, 0xcd, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x93, 0xe7, 0xbb, 0xb4,
	0x31, 0x0b, 0x00, 0x00,
}

func (this *StateMachineTransition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StateMachineTransition)
	if !ok {
		that2, ok := that.(StateMachineTransition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventId != that1.EventId {
		return false
	}
	if that1.Time == nil {
		if this.Time != nil {
			return false
		}
	} else if !this.Time.Equal(*that1.Time) {
		return false
	}
	return true
}
func (this *NexusOperationScheduled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationScheduled)
	if !ok {
		that2, ok := that.(NexusOperationScheduled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Attempt != that1.Attempt {
		return false
	}
	return true
}
func (this *NexusOperationStarted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationStarted)
	if !ok {
		that2, ok := that.(NexusOperationStarted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Transition.Equal(that1.Transition) {
		return false
	}
	if this.OperationId != that1.OperationId {
		return false
	}
	if !this.PreviousState.Equal(that1.PreviousState) {
		return false
	}
	return true
}
func (this *NexusOperationSucceeded) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationSucceeded)
	if !ok {
		that2, ok := that.(NexusOperationSucceeded)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Transition.Equal(that1.Transition) {
		return false
	}
	if that1.PreviousState == nil {
		if this.PreviousState != nil {
			return false
		}
	} else if this.PreviousState == nil {
		return false
	} else if !this.PreviousState.Equal(that1.PreviousState) {
		return false
	}
	return true
}
func (this *NexusOperationSucceeded_Scheduled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationSucceeded_Scheduled)
	if !ok {
		that2, ok := that.(NexusOperationSucceeded_Scheduled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Scheduled.Equal(that1.Scheduled) {
		return false
	}
	return true
}
func (this *NexusOperationSucceeded_Started) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationSucceeded_Started)
	if !ok {
		that2, ok := that.(NexusOperationSucceeded_Started)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Started.Equal(that1.Started) {
		return false
	}
	return true
}
func (this *NexusOperationSucceeded_CancelScheduled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationSucceeded_CancelScheduled)
	if !ok {
		that2, ok := that.(NexusOperationSucceeded_CancelScheduled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CancelScheduled.Equal(that1.CancelScheduled) {
		return false
	}
	return true
}
func (this *NexusOperationSucceeded_CancelStarted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationSucceeded_CancelStarted)
	if !ok {
		that2, ok := that.(NexusOperationSucceeded_CancelStarted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CancelStarted.Equal(that1.CancelStarted) {
		return false
	}
	return true
}
func (this *NexusOperationFailed) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationFailed)
	if !ok {
		that2, ok := that.(NexusOperationFailed)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Transition.Equal(that1.Transition) {
		return false
	}
	if that1.PreviousState == nil {
		if this.PreviousState != nil {
			return false
		}
	} else if this.PreviousState == nil {
		return false
	} else if !this.PreviousState.Equal(that1.PreviousState) {
		return false
	}
	return true
}
func (this *NexusOperationFailed_Scheduled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationFailed_Scheduled)
	if !ok {
		that2, ok := that.(NexusOperationFailed_Scheduled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Scheduled.Equal(that1.Scheduled) {
		return false
	}
	return true
}
func (this *NexusOperationFailed_Started) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationFailed_Started)
	if !ok {
		that2, ok := that.(NexusOperationFailed_Started)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Started.Equal(that1.Started) {
		return false
	}
	return true
}
func (this *NexusOperationFailed_CancelScheduled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationFailed_CancelScheduled)
	if !ok {
		that2, ok := that.(NexusOperationFailed_CancelScheduled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CancelScheduled.Equal(that1.CancelScheduled) {
		return false
	}
	return true
}
func (this *NexusOperationFailed_CancelStarted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationFailed_CancelStarted)
	if !ok {
		that2, ok := that.(NexusOperationFailed_CancelStarted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CancelStarted.Equal(that1.CancelStarted) {
		return false
	}
	return true
}
func (this *NexusOperationTimedOut) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationTimedOut)
	if !ok {
		that2, ok := that.(NexusOperationTimedOut)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Transition.Equal(that1.Transition) {
		return false
	}
	if that1.PreviousState == nil {
		if this.PreviousState != nil {
			return false
		}
	} else if this.PreviousState == nil {
		return false
	} else if !this.PreviousState.Equal(that1.PreviousState) {
		return false
	}
	return true
}
func (this *NexusOperationTimedOut_Scheduled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationTimedOut_Scheduled)
	if !ok {
		that2, ok := that.(NexusOperationTimedOut_Scheduled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Scheduled.Equal(that1.Scheduled) {
		return false
	}
	return true
}
func (this *NexusOperationTimedOut_Started) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationTimedOut_Started)
	if !ok {
		that2, ok := that.(NexusOperationTimedOut_Started)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Started.Equal(that1.Started) {
		return false
	}
	return true
}
func (this *NexusOperationTimedOut_CancelScheduled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationTimedOut_CancelScheduled)
	if !ok {
		that2, ok := that.(NexusOperationTimedOut_CancelScheduled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CancelScheduled.Equal(that1.CancelScheduled) {
		return false
	}
	return true
}
func (this *NexusOperationTimedOut_CancelStarted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationTimedOut_CancelStarted)
	if !ok {
		that2, ok := that.(NexusOperationTimedOut_CancelStarted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CancelStarted.Equal(that1.CancelStarted) {
		return false
	}
	return true
}
func (this *NexusOperationCancelScheduled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationCancelScheduled)
	if !ok {
		that2, ok := that.(NexusOperationCancelScheduled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Transition.Equal(that1.Transition) {
		return false
	}
	if that1.PreviousState == nil {
		if this.PreviousState != nil {
			return false
		}
	} else if this.PreviousState == nil {
		return false
	} else if !this.PreviousState.Equal(that1.PreviousState) {
		return false
	}
	return true
}
func (this *NexusOperationCancelScheduled_Scheduled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationCancelScheduled_Scheduled)
	if !ok {
		that2, ok := that.(NexusOperationCancelScheduled_Scheduled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Scheduled.Equal(that1.Scheduled) {
		return false
	}
	return true
}
func (this *NexusOperationCancelScheduled_Started) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationCancelScheduled_Started)
	if !ok {
		that2, ok := that.(NexusOperationCancelScheduled_Started)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Started.Equal(that1.Started) {
		return false
	}
	return true
}
func (this *NexusOperationCancelStarted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NexusOperationCancelStarted)
	if !ok {
		that2, ok := that.(NexusOperationCancelStarted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventId != that1.EventId {
		return false
	}
	if this.EventBatchId != that1.EventBatchId {
		return false
	}
	if that1.Time == nil {
		if this.Time != nil {
			return false
		}
	} else if !this.Time.Equal(*that1.Time) {
		return false
	}
	if !this.StartedState.Equal(that1.StartedState) {
		return false
	}
	return true
}
func (this *StateMachineTransition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&persistence.StateMachineTransition{")
	s = append(s, "EventId: "+fmt.Sprintf("%#v", this.EventId)+",\n")
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NexusOperationScheduled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&persistence.NexusOperationScheduled{")
	s = append(s, "Attempt: "+fmt.Sprintf("%#v", this.Attempt)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NexusOperationStarted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&persistence.NexusOperationStarted{")
	if this.Transition != nil {
		s = append(s, "Transition: "+fmt.Sprintf("%#v", this.Transition)+",\n")
	}
	s = append(s, "OperationId: "+fmt.Sprintf("%#v", this.OperationId)+",\n")
	if this.PreviousState != nil {
		s = append(s, "PreviousState: "+fmt.Sprintf("%#v", this.PreviousState)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NexusOperationSucceeded) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&persistence.NexusOperationSucceeded{")
	if this.Transition != nil {
		s = append(s, "Transition: "+fmt.Sprintf("%#v", this.Transition)+",\n")
	}
	if this.PreviousState != nil {
		s = append(s, "PreviousState: "+fmt.Sprintf("%#v", this.PreviousState)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NexusOperationSucceeded_Scheduled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationSucceeded_Scheduled{` +
		`Scheduled:` + fmt.Sprintf("%#v", this.Scheduled) + `}`}, ", ")
	return s
}
func (this *NexusOperationSucceeded_Started) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationSucceeded_Started{` +
		`Started:` + fmt.Sprintf("%#v", this.Started) + `}`}, ", ")
	return s
}
func (this *NexusOperationSucceeded_CancelScheduled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationSucceeded_CancelScheduled{` +
		`CancelScheduled:` + fmt.Sprintf("%#v", this.CancelScheduled) + `}`}, ", ")
	return s
}
func (this *NexusOperationSucceeded_CancelStarted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationSucceeded_CancelStarted{` +
		`CancelStarted:` + fmt.Sprintf("%#v", this.CancelStarted) + `}`}, ", ")
	return s
}
func (this *NexusOperationFailed) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&persistence.NexusOperationFailed{")
	if this.Transition != nil {
		s = append(s, "Transition: "+fmt.Sprintf("%#v", this.Transition)+",\n")
	}
	if this.PreviousState != nil {
		s = append(s, "PreviousState: "+fmt.Sprintf("%#v", this.PreviousState)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NexusOperationFailed_Scheduled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationFailed_Scheduled{` +
		`Scheduled:` + fmt.Sprintf("%#v", this.Scheduled) + `}`}, ", ")
	return s
}
func (this *NexusOperationFailed_Started) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationFailed_Started{` +
		`Started:` + fmt.Sprintf("%#v", this.Started) + `}`}, ", ")
	return s
}
func (this *NexusOperationFailed_CancelScheduled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationFailed_CancelScheduled{` +
		`CancelScheduled:` + fmt.Sprintf("%#v", this.CancelScheduled) + `}`}, ", ")
	return s
}
func (this *NexusOperationFailed_CancelStarted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationFailed_CancelStarted{` +
		`CancelStarted:` + fmt.Sprintf("%#v", this.CancelStarted) + `}`}, ", ")
	return s
}
func (this *NexusOperationTimedOut) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&persistence.NexusOperationTimedOut{")
	if this.Transition != nil {
		s = append(s, "Transition: "+fmt.Sprintf("%#v", this.Transition)+",\n")
	}
	if this.PreviousState != nil {
		s = append(s, "PreviousState: "+fmt.Sprintf("%#v", this.PreviousState)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NexusOperationTimedOut_Scheduled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationTimedOut_Scheduled{` +
		`Scheduled:` + fmt.Sprintf("%#v", this.Scheduled) + `}`}, ", ")
	return s
}
func (this *NexusOperationTimedOut_Started) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationTimedOut_Started{` +
		`Started:` + fmt.Sprintf("%#v", this.Started) + `}`}, ", ")
	return s
}
func (this *NexusOperationTimedOut_CancelScheduled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationTimedOut_CancelScheduled{` +
		`CancelScheduled:` + fmt.Sprintf("%#v", this.CancelScheduled) + `}`}, ", ")
	return s
}
func (this *NexusOperationTimedOut_CancelStarted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationTimedOut_CancelStarted{` +
		`CancelStarted:` + fmt.Sprintf("%#v", this.CancelStarted) + `}`}, ", ")
	return s
}
func (this *NexusOperationCancelScheduled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&persistence.NexusOperationCancelScheduled{")
	if this.Transition != nil {
		s = append(s, "Transition: "+fmt.Sprintf("%#v", this.Transition)+",\n")
	}
	if this.PreviousState != nil {
		s = append(s, "PreviousState: "+fmt.Sprintf("%#v", this.PreviousState)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NexusOperationCancelScheduled_Scheduled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationCancelScheduled_Scheduled{` +
		`Scheduled:` + fmt.Sprintf("%#v", this.Scheduled) + `}`}, ", ")
	return s
}
func (this *NexusOperationCancelScheduled_Started) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NexusOperationCancelScheduled_Started{` +
		`Started:` + fmt.Sprintf("%#v", this.Started) + `}`}, ", ")
	return s
}
func (this *NexusOperationCancelStarted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&persistence.NexusOperationCancelStarted{")
	s = append(s, "EventId: "+fmt.Sprintf("%#v", this.EventId)+",\n")
	s = append(s, "EventBatchId: "+fmt.Sprintf("%#v", this.EventBatchId)+",\n")
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	if this.StartedState != nil {
		s = append(s, "StartedState: "+fmt.Sprintf("%#v", this.StartedState)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringNexusoperation(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *StateMachineTransition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineTransition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineTransition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Time, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Time):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintNexusoperation(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x1a
	}
	if m.EventId != 0 {
		i = encodeVarintNexusoperation(dAtA, i, uint64(m.EventId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NexusOperationScheduled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexusOperationScheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationScheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Attempt != 0 {
		i = encodeVarintNexusoperation(dAtA, i, uint64(m.Attempt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NexusOperationStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexusOperationStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreviousState != nil {
		{
			size, err := m.PreviousState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OperationId) > 0 {
		i -= len(m.OperationId)
		copy(dAtA[i:], m.OperationId)
		i = encodeVarintNexusoperation(dAtA, i, uint64(len(m.OperationId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Transition != nil {
		{
			size, err := m.Transition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexusOperationSucceeded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexusOperationSucceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationSucceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreviousState != nil {
		{
			size := m.PreviousState.Size()
			i -= size
			if _, err := m.PreviousState.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Transition != nil {
		{
			size, err := m.Transition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexusOperationSucceeded_Scheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationSucceeded_Scheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scheduled != nil {
		{
			size, err := m.Scheduled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationSucceeded_Started) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationSucceeded_Started) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationSucceeded_CancelScheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationSucceeded_CancelScheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelScheduled != nil {
		{
			size, err := m.CancelScheduled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationSucceeded_CancelStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationSucceeded_CancelStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelStarted != nil {
		{
			size, err := m.CancelStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationFailed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexusOperationFailed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationFailed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreviousState != nil {
		{
			size := m.PreviousState.Size()
			i -= size
			if _, err := m.PreviousState.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Transition != nil {
		{
			size, err := m.Transition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexusOperationFailed_Scheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationFailed_Scheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scheduled != nil {
		{
			size, err := m.Scheduled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationFailed_Started) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationFailed_Started) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationFailed_CancelScheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationFailed_CancelScheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelScheduled != nil {
		{
			size, err := m.CancelScheduled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationFailed_CancelStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationFailed_CancelStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelStarted != nil {
		{
			size, err := m.CancelStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationTimedOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexusOperationTimedOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationTimedOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreviousState != nil {
		{
			size := m.PreviousState.Size()
			i -= size
			if _, err := m.PreviousState.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Transition != nil {
		{
			size, err := m.Transition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexusOperationTimedOut_Scheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationTimedOut_Scheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scheduled != nil {
		{
			size, err := m.Scheduled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationTimedOut_Started) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationTimedOut_Started) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationTimedOut_CancelScheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationTimedOut_CancelScheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelScheduled != nil {
		{
			size, err := m.CancelScheduled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationTimedOut_CancelStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationTimedOut_CancelStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelStarted != nil {
		{
			size, err := m.CancelStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationCancelScheduled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexusOperationCancelScheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationCancelScheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreviousState != nil {
		{
			size := m.PreviousState.Size()
			i -= size
			if _, err := m.PreviousState.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Transition != nil {
		{
			size, err := m.Transition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexusOperationCancelScheduled_Scheduled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationCancelScheduled_Scheduled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scheduled != nil {
		{
			size, err := m.Scheduled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationCancelScheduled_Started) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationCancelScheduled_Started) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NexusOperationCancelStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexusOperationCancelStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexusOperationCancelStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartedState != nil {
		{
			size, err := m.StartedState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNexusoperation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Time != nil {
		n23, err23 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Time, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Time):])
		if err23 != nil {
			return 0, err23
		}
		i -= n23
		i = encodeVarintNexusoperation(dAtA, i, uint64(n23))
		i--
		dAtA[i] = 0x1a
	}
	if m.EventBatchId != 0 {
		i = encodeVarintNexusoperation(dAtA, i, uint64(m.EventBatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.EventId != 0 {
		i = encodeVarintNexusoperation(dAtA, i, uint64(m.EventId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNexusoperation(dAtA []byte, offset int, v uint64) int {
	offset -= sovNexusoperation(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StateMachineTransition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventId != 0 {
		n += 1 + sovNexusoperation(uint64(m.EventId))
	}
	if m.Time != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Time)
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}

func (m *NexusOperationScheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Attempt != 0 {
		n += 1 + sovNexusoperation(uint64(m.Attempt))
	}
	return n
}

func (m *NexusOperationStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transition != nil {
		l = m.Transition.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	l = len(m.OperationId)
	if l > 0 {
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	if m.PreviousState != nil {
		l = m.PreviousState.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}

func (m *NexusOperationSucceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transition != nil {
		l = m.Transition.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	if m.PreviousState != nil {
		n += m.PreviousState.Size()
	}
	return n
}

func (m *NexusOperationSucceeded_Scheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scheduled != nil {
		l = m.Scheduled.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationSucceeded_Started) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationSucceeded_CancelScheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelScheduled != nil {
		l = m.CancelScheduled.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationSucceeded_CancelStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelStarted != nil {
		l = m.CancelStarted.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transition != nil {
		l = m.Transition.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	if m.PreviousState != nil {
		n += m.PreviousState.Size()
	}
	return n
}

func (m *NexusOperationFailed_Scheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scheduled != nil {
		l = m.Scheduled.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationFailed_Started) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationFailed_CancelScheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelScheduled != nil {
		l = m.CancelScheduled.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationFailed_CancelStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelStarted != nil {
		l = m.CancelStarted.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationTimedOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transition != nil {
		l = m.Transition.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	if m.PreviousState != nil {
		n += m.PreviousState.Size()
	}
	return n
}

func (m *NexusOperationTimedOut_Scheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scheduled != nil {
		l = m.Scheduled.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationTimedOut_Started) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationTimedOut_CancelScheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelScheduled != nil {
		l = m.CancelScheduled.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationTimedOut_CancelStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelStarted != nil {
		l = m.CancelStarted.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationCancelScheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transition != nil {
		l = m.Transition.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	if m.PreviousState != nil {
		n += m.PreviousState.Size()
	}
	return n
}

func (m *NexusOperationCancelScheduled_Scheduled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scheduled != nil {
		l = m.Scheduled.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationCancelScheduled_Started) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}
func (m *NexusOperationCancelStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventId != 0 {
		n += 1 + sovNexusoperation(uint64(m.EventId))
	}
	if m.EventBatchId != 0 {
		n += 1 + sovNexusoperation(uint64(m.EventBatchId))
	}
	if m.Time != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Time)
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	if m.StartedState != nil {
		l = m.StartedState.Size()
		n += 1 + l + sovNexusoperation(uint64(l))
	}
	return n
}

func sovNexusoperation(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNexusoperation(x uint64) (n int) {
	return sovNexusoperation(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *StateMachineTransition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StateMachineTransition{`,
		`EventId:` + fmt.Sprintf("%v", this.EventId) + `,`,
		`Time:` + strings.Replace(fmt.Sprintf("%v", this.Time), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationScheduled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationScheduled{`,
		`Attempt:` + fmt.Sprintf("%v", this.Attempt) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationStarted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationStarted{`,
		`Transition:` + strings.Replace(this.Transition.String(), "StateMachineTransition", "StateMachineTransition", 1) + `,`,
		`OperationId:` + fmt.Sprintf("%v", this.OperationId) + `,`,
		`PreviousState:` + strings.Replace(this.PreviousState.String(), "NexusOperationScheduled", "NexusOperationScheduled", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationSucceeded) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationSucceeded{`,
		`Transition:` + strings.Replace(this.Transition.String(), "StateMachineTransition", "StateMachineTransition", 1) + `,`,
		`PreviousState:` + fmt.Sprintf("%v", this.PreviousState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationSucceeded_Scheduled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationSucceeded_Scheduled{`,
		`Scheduled:` + strings.Replace(fmt.Sprintf("%v", this.Scheduled), "NexusOperationScheduled", "NexusOperationScheduled", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationSucceeded_Started) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationSucceeded_Started{`,
		`Started:` + strings.Replace(fmt.Sprintf("%v", this.Started), "NexusOperationStarted", "NexusOperationStarted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationSucceeded_CancelScheduled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationSucceeded_CancelScheduled{`,
		`CancelScheduled:` + strings.Replace(fmt.Sprintf("%v", this.CancelScheduled), "NexusOperationCancelScheduled", "NexusOperationCancelScheduled", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationSucceeded_CancelStarted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationSucceeded_CancelStarted{`,
		`CancelStarted:` + strings.Replace(fmt.Sprintf("%v", this.CancelStarted), "NexusOperationCancelStarted", "NexusOperationCancelStarted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationFailed) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationFailed{`,
		`Transition:` + strings.Replace(this.Transition.String(), "StateMachineTransition", "StateMachineTransition", 1) + `,`,
		`PreviousState:` + fmt.Sprintf("%v", this.PreviousState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationFailed_Scheduled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationFailed_Scheduled{`,
		`Scheduled:` + strings.Replace(fmt.Sprintf("%v", this.Scheduled), "NexusOperationScheduled", "NexusOperationScheduled", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationFailed_Started) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationFailed_Started{`,
		`Started:` + strings.Replace(fmt.Sprintf("%v", this.Started), "NexusOperationStarted", "NexusOperationStarted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationFailed_CancelScheduled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationFailed_CancelScheduled{`,
		`CancelScheduled:` + strings.Replace(fmt.Sprintf("%v", this.CancelScheduled), "NexusOperationCancelScheduled", "NexusOperationCancelScheduled", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationFailed_CancelStarted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationFailed_CancelStarted{`,
		`CancelStarted:` + strings.Replace(fmt.Sprintf("%v", this.CancelStarted), "NexusOperationCancelStarted", "NexusOperationCancelStarted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationTimedOut) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationTimedOut{`,
		`Transition:` + strings.Replace(this.Transition.String(), "StateMachineTransition", "StateMachineTransition", 1) + `,`,
		`PreviousState:` + fmt.Sprintf("%v", this.PreviousState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationTimedOut_Scheduled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationTimedOut_Scheduled{`,
		`Scheduled:` + strings.Replace(fmt.Sprintf("%v", this.Scheduled), "NexusOperationScheduled", "NexusOperationScheduled", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationTimedOut_Started) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationTimedOut_Started{`,
		`Started:` + strings.Replace(fmt.Sprintf("%v", this.Started), "NexusOperationStarted", "NexusOperationStarted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationTimedOut_CancelScheduled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationTimedOut_CancelScheduled{`,
		`CancelScheduled:` + strings.Replace(fmt.Sprintf("%v", this.CancelScheduled), "NexusOperationCancelScheduled", "NexusOperationCancelScheduled", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationTimedOut_CancelStarted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationTimedOut_CancelStarted{`,
		`CancelStarted:` + strings.Replace(fmt.Sprintf("%v", this.CancelStarted), "NexusOperationCancelStarted", "NexusOperationCancelStarted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationCancelScheduled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationCancelScheduled{`,
		`Transition:` + strings.Replace(this.Transition.String(), "StateMachineTransition", "StateMachineTransition", 1) + `,`,
		`PreviousState:` + fmt.Sprintf("%v", this.PreviousState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationCancelScheduled_Scheduled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationCancelScheduled_Scheduled{`,
		`Scheduled:` + strings.Replace(fmt.Sprintf("%v", this.Scheduled), "NexusOperationScheduled", "NexusOperationScheduled", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationCancelScheduled_Started) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationCancelScheduled_Started{`,
		`Started:` + strings.Replace(fmt.Sprintf("%v", this.Started), "NexusOperationStarted", "NexusOperationStarted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NexusOperationCancelStarted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NexusOperationCancelStarted{`,
		`EventId:` + fmt.Sprintf("%v", this.EventId) + `,`,
		`EventBatchId:` + fmt.Sprintf("%v", this.EventBatchId) + `,`,
		`Time:` + strings.Replace(fmt.Sprintf("%v", this.Time), "Timestamp", "types.Timestamp", 1) + `,`,
		`StartedState:` + strings.Replace(this.StartedState.String(), "NexusOperationStarted", "NexusOperationStarted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringNexusoperation(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *StateMachineTransition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNexusoperation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineTransition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineTransition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNexusoperation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexusOperationScheduled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNexusoperation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexusOperationScheduled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexusOperationScheduled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attempt", wireType)
			}
			m.Attempt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attempt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNexusoperation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexusOperationStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNexusoperation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexusOperationStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexusOperationStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transition == nil {
				m.Transition = &StateMachineTransition{}
			}
			if err := m.Transition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousState == nil {
				m.PreviousState = &NexusOperationScheduled{}
			}
			if err := m.PreviousState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNexusoperation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexusOperationSucceeded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNexusoperation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexusOperationSucceeded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexusOperationSucceeded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transition == nil {
				m.Transition = &StateMachineTransition{}
			}
			if err := m.Transition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationScheduled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationSucceeded_Scheduled{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationSucceeded_Started{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelScheduled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationCancelScheduled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationSucceeded_CancelScheduled{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationCancelStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationSucceeded_CancelStarted{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNexusoperation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexusOperationFailed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNexusoperation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexusOperationFailed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexusOperationFailed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transition == nil {
				m.Transition = &StateMachineTransition{}
			}
			if err := m.Transition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationScheduled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationFailed_Scheduled{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationFailed_Started{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelScheduled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationCancelScheduled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationFailed_CancelScheduled{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationCancelStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationFailed_CancelStarted{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNexusoperation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexusOperationTimedOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNexusoperation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexusOperationTimedOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexusOperationTimedOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transition == nil {
				m.Transition = &StateMachineTransition{}
			}
			if err := m.Transition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationScheduled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationTimedOut_Scheduled{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationTimedOut_Started{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelScheduled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationCancelScheduled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationTimedOut_CancelScheduled{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationCancelStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationTimedOut_CancelStarted{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNexusoperation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexusOperationCancelScheduled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNexusoperation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexusOperationCancelScheduled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexusOperationCancelScheduled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transition == nil {
				m.Transition = &StateMachineTransition{}
			}
			if err := m.Transition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationScheduled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationCancelScheduled_Scheduled{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NexusOperationStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PreviousState = &NexusOperationCancelScheduled_Started{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNexusoperation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexusOperationCancelStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNexusoperation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexusOperationCancelStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexusOperationCancelStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventBatchId", wireType)
			}
			m.EventBatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventBatchId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNexusoperation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedState == nil {
				m.StartedState = &NexusOperationStarted{}
			}
			if err := m.StartedState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNexusoperation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNexusoperation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNexusoperation(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNexusoperation
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNexusoperation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNexusoperation
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNexusoperation
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNexusoperation
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNexusoperation        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNexusoperation          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNexusoperation = fmt.Errorf("proto: unexpected end of group")
)
